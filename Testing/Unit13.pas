// Although this unit has been autogenerated, it is intended to be modified.
// Source uSpecialAuthority, Date: 8/2/2024 10:46:41 AM

unit Unit13;

{$RTTI EXPLICIT METHODS([vcProtected, vcPublic, vcPublished])}

interface

uses
  System.Generics.Collections,
  System.JSON,
  System.JSON.Serializers,
  uSpecialAuthority;

type
  TJMSpecialAuthorities = class;

  TJMSpecialAuthority = class(TSpecialAuthority)
  private
    FOwnerJMSpecialAuthorities: TJMSpecialAuthorities;
    function GetHasOwner: Boolean;
  protected
    procedure PopulateOwner(AOwner: TJMSpecialAuthorities);
  public
    property OwnerJMSpecialAuthorities: TJMSpecialAuthorities
      read FOwnerJMSpecialAuthorities;
    [JSONIn]
    property HasOwner: Boolean read GetHasOwner;
  end;

  TJMSpecialAuthorities = class(TSpecialAuthorities)
  private
    FJMSpecialAuthority: TObjectList<TJMSpecialAuthority>;
  protected
    procedure PopulateOwner;
  public
    constructor Create;
    destructor Destroy; override;
    property SpecialAuthority: TObjectList<TJMSpecialAuthority>
      read FJMSpecialAuthority;
  end;

  TJMSpecialAuthoritiesConverter = class(TObject)
  private
    class function InternalToObject<T, U: class>(JSONValue: TJSONValue;
      JSONString: string; AOwner: U): T;
    class function LibraryName: string;
  public
    class function ToJSON<T>(AObject: T): string;
    class function ToObject<T, U: class>(JSON: TJSONValue; AOwner: U)
      : T; overload;
    class function ToObject<T, U: class>(JSON: string; AOwner: U): T; overload;
    class function ToObject<T: class>(JSON: string): T; overload;
    class function ToObject<T: class>(JSON: TJSONValue): T; overload;
  end;

implementation

uses
  System.SysUtils,
  System.JSON.Converters,
  System.JSON.Writers,
  System.JSON.Readers,
  System.Rtti,
  System.TypInfo,
  VAShared.RttiUtils,
  Unit12;

var
  JMSpecialAuthoritiesJSONLibrary: string;
  JMSpecialAuthoritiesJSONSerializerRegistered: Boolean = False;

procedure FreeAndNilOld(ATypeInf: PTypeInfo; Instance: TObject;
  FieldName: string);
var
  LField: TRttiField;
begin
  LField := GetRttiField(ATypeInf, FieldName);
  if Assigned(LField) then
  begin
    LField.GetValue(Instance).AsObject.Free;
    LField.SetValue(Instance, nil);
  end;
end;

{ TJMSpecialAuthority }

function TJMSpecialAuthority.GetHasOwner: Boolean;
begin
  Result := Assigned(FOwnerJMSpecialAuthorities) and
    (FOwnerJMSpecialAuthorities = Unit12.SA);
end;

procedure TJMSpecialAuthority.PopulateOwner(AOwner: TJMSpecialAuthorities);
begin
  FOwnerJMSpecialAuthorities := AOwner;
end;

{ TJMSpecialAuthorities }

constructor TJMSpecialAuthorities.Create;
begin
  inherited Create;
  FreeAndNilOld(TypeInfo(TObjectList<TSpecialAuthority>), Self,
    'FSpecialAuthority');
  FJMSpecialAuthority := TObjectList<TJMSpecialAuthority>.Create(True);
end;

destructor TJMSpecialAuthorities.Destroy;
begin
  FreeAndNil(FJMSpecialAuthority);
  inherited;
end;

procedure TJMSpecialAuthorities.PopulateOwner;
begin
  for var I := 0 to FJMSpecialAuthority.Count - 1 do
    FJMSpecialAuthority[I].PopulateOwner(Self);
end;

{ TJMSpecialAuthoritiesConverter }

class function TJMSpecialAuthoritiesConverter.InternalToObject<T, U>
  (JSONValue: TJSONValue; JSONString: string; AOwner: U): T;
var
  Ctx: TRttiContext;
  LArgs: array of TValue;
  LMethod: TRttiMethod;
  LType: TRttiType;
begin
  TJSONMapper<T>.SetDefaultLibrary(LibraryName);
  if Assigned(JSONValue) then
    Result := TJSONMapper<T>.Default.FromObject(JSONValue)
  else
    Result := TJSONMapper<T>.Default.FromObject(JSONString);
  { Ctx := TRttiContext.Create;
    try
    LType := Ctx.GetType(Result.ClassInfo);
    for LMethod in LType.GetMethods do
    if Assigned(LMethod) and LMethod.HasName('PopulateOwner') then
    begin
    if Length(LMethod.GetParameters) > 0 then
    begin
    SetLength(LArgs, 1);
    LArgs[0] := TValue.From<U>(AOwner);
    end;
    LMethod.Invoke(Result, LArgs);
    exit;
    end;
    finally
    Ctx.Free;
    end;
  }
end;

class function TJMSpecialAuthoritiesConverter.LibraryName: string;
begin
  Result := QualifiedClassName;
  if Result.EndsWith('.' + ClassName) then
    delete(Result, Length(QualifiedClassName) - Length(ClassName) - 1, MaxInt);
end;

class function TJMSpecialAuthoritiesConverter.ToJSON<T>(AObject: T): string;
begin
  TJSONMapper<T>.SetDefaultLibrary(LibraryName);
  Result := TJSONMapper<T>.Default.ToString(AObject);
end;

class function TJMSpecialAuthoritiesConverter.ToObject<T, U>(JSON: TJSONValue;
  AOwner: U): T;
begin
  Result := InternalToObject<T, U>(JSON, '', AOwner);
end;

class function TJMSpecialAuthoritiesConverter.ToObject<T, U>(JSON: string;
  AOwner: U): T;
begin
  Result := InternalToObject<T, U>(nil, JSON, AOwner);
end;

class function TJMSpecialAuthoritiesConverter.ToObject<T>(JSON: string): T;
begin
  Result := InternalToObject<T, TObject>(nil, JSON, nil);
end;

class function TJMSpecialAuthoritiesConverter.ToObject<T>(JSON: TJSONValue): T;
begin
  Result := InternalToObject<T, TObject>(JSON, '', nil);
end;

type
  TJsonListConverterJMSpecialAuthority = class
    (TJsonTypedListConverter<TJMSpecialAuthority>);

  TJMSpecialAuthoritiesJSONSerializer = class(TJsonSerializer)
  public
    constructor Create;
  end;

  TSpecialAuthorityConverter = class(TJsonCustomCreationConverter<TJMSpecialAuthority>)
  class var
    FOwner: TJMSpecialAuthorities;
  protected
    function CreateInstance(ATypeInf: PTypeInfo): TValue; override;
  end;

  { TJMSpecialAuthoritiesJSONSerializer }

constructor TJMSpecialAuthoritiesJSONSerializer.Create;
var
  AAttributes: TJsonDynamicAttributes;
  AFieldType: TRttiType;
  AResolver: TJsonDynamicContractResolver;
  Ctx: TRttiContext;

  procedure Init;
  var
    LField: TRttiField;
  begin
    AResolver := TJsonDynamicContractResolver.Create
      (TJsonMemberSerialization.Public);
    ContractResolver := AResolver;
    LField := GetRttiField(TypeInfo(TJsonDynamicContractResolver),
      'FDynamicAttributes');
    if Assigned(LField) then
      AAttributes := LField.GetValue(AResolver).AsType<TJsonDynamicAttributes>
    else
      AAttributes := nil;
    AFieldType := Ctx.GetType(TRttiType);
  end;

  procedure IgnoreProperties(AClass: TClass; ATypeInf: PTypeInfo);
  var
    I, J: Integer;
    LProp: TRttiProperty;
    LType: TRttiType;
    PropList: TArray<string>;
  begin
    LType := Ctx.GetType(ATypeInf);
    for LProp in LType.GetProperties do
    begin
      if LProp.HasAttribute<JsonInAttribute> then
        continue;
      if (not(LProp.Visibility in [mvPublic, mvPublished])) or
        (LProp.Parent.Name <> AClass.ClassName) then
      begin
        SetLength(PropList, Length(PropList) + 1);
        PropList[Length(PropList) - 1] := LProp.Name;
      end;
    end;
    for I := Length(PropList) - 1 downto 0 do
      for LProp in LType.GetProperties do
        if (CompareText(PropList[I], LProp.Name) = 0) and
          (LProp.Parent.Name = AClass.ClassName) then
        begin
          AResolver.SetPropertyName(ATypeInf, PropList[I], LProp.Name);
          for J := I to Length(PropList) - 2 do
            PropList[J] := PropList[J + 1];
          SetLength(PropList, Length(PropList) - 1);
          AAttributes.AddAttribute(LProp, JsonIgnoreAttribute.Create);
          break;
        end;
    AResolver.SetPropertiesIgnored(ATypeInf, PropList);
  end;

begin
  inherited Create;
  Ctx := TRttiContext.Create;
  try
    Init;
    IgnoreProperties(TSpecialAuthority, TypeInfo(TJMSpecialAuthority));
    IgnoreProperties(TSpecialAuthorities, TypeInfo(TJMSpecialAuthorities));
    AResolver.SetPropertyConverter(TypeInfo(TJMSpecialAuthorities),
      'SpecialAuthority', TJsonListConverterJMSpecialAuthority);
    AResolver.SetTypeConverter(TypeInfo(TJMSpecialAuthority),
      TOwnerConverter<TJMSpecialAuthority, TObject>);
    AResolver.SetTypeConverter(TypeInfo(TJMSpecialAuthorities),
      TOwnerConverter<TJMSpecialAuthorities, TJMSpecialAuthority>);
  finally
    Ctx.Free;
  end;
end;

{ TOwnerConverter<T, U> }
{
function TOwnerConverter<T, U>.CreateInstance(ATypeInf: PTypeInfo): TValue;
var
  Obj: T;
  Ctx: TRttiContext;
  LArgs: array of TValue;
  LMethod: TRttiMethod;
  LType: TRttiType;
begin
  Obj := T.Create;

  Ctx := TRttiContext.Create;
  try
    LType := Ctx.GetType(Obj.ClassInfo);
    for LMethod in LType.GetMethods do
      if Assigned(LMethod) and LMethod.HasName('PopulateOwner') then
      begin
        if Length(LMethod.GetParameters) > 0 then
        begin
          SetLength(LArgs, 1);
          LArgs[0] := TValue.From<U>(FOwner);
        end;
        LMethod.Invoke(Result, LArgs);
      end;
  finally
    Ctx.Free;
    TValue.Make<T>(Obj, Result);
  end;
end;
    }

initialization

JMSpecialAuthoritiesJSONLibrary := TJMSpecialAuthoritiesConverter.LibraryName;
JMSpecialAuthoritiesJSONSerializerRegistered := TJSONMappers.RegisterLibrary
  (JMSpecialAuthoritiesJSONLibrary, TJSONMappers.TOptionality.DontCare,
  TJSONMappers.TOptionality.DontCare, TJSONMappers.TOptionality.DontCare,
  procedure(const AName: string; const ASerItems: TJSONMappers.TItem;
    var AIntro: string; var AReqUnit: string)
  const
    CSerItems: array [TJSONMappers.TItem] of string = ('Public', 'Fields');
  begin
    AIntro := '[JsonSerialize(TJsonMemberSerialization.' + CSerItems
      [ASerItems] + ')]';
    AReqUnit := JMSpecialAuthoritiesJSONLibrary;
  end,
  procedure(const AName, AOrigName: string; const AElem: TJSONMappers.TItem;
    var AIntro: string; var AReqUnit: string)
  begin
    if AnsiSameText(AName, AOrigName) and (AElem <> TJSONMappers.TItem.Field)
    then
      Exit;
    AIntro := '[JsonName(''' + AOrigName + ''')]';
    AReqUnit := JMSpecialAuthoritiesJSONLibrary;
  end,
  procedure(const AItemType: string; var AIntro, AReqUnit,
    AInstantiation: string)
  begin
    var
    LConv := StringReplace(AItemType, '<', '', [TReplaceFlag.rfReplaceAll]);
    LConv := 'TJsonListConverter' + StringReplace(LConv, '>', '',
      [TReplaceFlag.rfReplaceAll]);
    AIntro := '[JsonConverter(' + LConv + ')]';
    AReqUnit := JMSpecialAuthoritiesJSONLibrary;
    AInstantiation := LConv + ' = class(TJsonListConverter<' + AItemType + '>)';
  end,
  function(ApValue: Pointer; ApTypeInfo: PTypeInfo): TJSONObject
  var
    LSer: TJMSpecialAuthoritiesJSONSerializer;
    LWrt: TJsonObjectWriter;
    V: TValue;
  begin
    LSer := TJMSpecialAuthoritiesJSONSerializer.Create;
    LWrt := TJsonObjectWriter.Create(False);
    try
      TValue.Make(ApValue, ApTypeInfo, V);
      LSer.Serialize(LWrt, V);
      Result := LWrt.JSON as TJSONObject;
    finally
      LWrt.Free;
      LSer.Free;
    end;
  end,
  function(AValue: TJSONObject; ApTypeInfo: PTypeInfo): TValue
  var
    LSer: TJMSpecialAuthoritiesJSONSerializer;
    LRdr: TJsonObjectReader;
  begin
    LSer := TJMSpecialAuthoritiesJSONSerializer.Create;
    LRdr := TJsonObjectReader.Create(AValue);
    try
      Result := LSer.Deserialize(LRdr, ApTypeInfo);
    finally
      LRdr.Free;
      LSer.Free;
    end;
  end);

finalization

if JMSpecialAuthoritiesJSONSerializerRegistered then
  TJSONMappers.UnRegisterLibrary(JMSpecialAuthoritiesJSONLibrary);

end.
